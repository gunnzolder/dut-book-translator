Алгоритм BloomQuery(Елемент: y, Фільтр Блума: B)
початок
  Ініціалізувати BooleanFlag = 1;
  для i = 1 до w зробити
    BooleanFlag = BooleanFlag AND h_i(y);
  повернути BooleanFlag;
кінець

[Рисунок 12.3: Перевірка членства за допомогою фільтра Блума, сторінка 401]

Доведення: Розглянемо конкретний біт, що відповідає елементу бітового масиву h_r(y) для деякого фіксованого значення індексу r ∈ {1...w}. Кожен елемент x ∈ S встановлює u різних бітів h_1(x)...h_u(x) в 1. Ймовірність того, що жоден з цих бітів не збігається з h_r(y), дається виразом (1 - 1/m)^u. Для n різних елементів потоку ця ймовірність дорівнює (1 - 1/m)^un. Отже, ймовірність того, що бітовий масив з індексом h_r(y) встановлено в 1 принаймні одним з n сторонніх елементів в S, дається виразом Q = 1 - (1 - 1/m)^un. Хибний позитивний результат виникає, коли всі індекси бітового масиву h_r(y) (для різних значень r ∈ {1...w}) встановлені в 1. Ймовірність цього дорівнює F = Q^w. Результат випливає.

Хоча ймовірність хибного позитивного результату виражена вище через кількість різних елементів потоку, це тривіально справедливо для загальної кількості елементів потоку (включаючи повтори), як верхня межа.

Вираз у вищезгаданій лемі можна спростити, спостерігаючи, що (1 - 1/m)^m ≈ e^(-1), де e - основа натурального логарифму. Відповідно, вираз можна переписати наступним чином:
$$
F = (1 - e^{-u/m})^w.
$$
(12.19)

Занадто малі або занадто великі значення u призводять до поганої продуктивності. Значення u необхідно вибрати оптимально з точки зору m та n, щоб мінімізувати кількість хибних позитивних результатів. Кількість хибних позитивних результатів мінімізується, коли u = m * ln(2)/n. Підставляючи це значення в рівняння 12.19, можна показати, що ймовірність хибних позитивних результатів для оптимальної кількості хеш-функцій дорівнює:
$$
F = 2^{-m \cdot ln(2)/n}.
$$
(12.20)

Вираз вище можна записати виключно як вираз m/n. Отже, для фіксованого значення ймовірності хибного позитивного результату F, довжина фільтра Блума повинна бути пропорційною кількості різних елементів n у потоці даних. Більше того, константа пропорційності для конкретної ймовірності хибного позитивного результату F може бути показана як
$$
\frac{m}{n} = \left(\frac{\ln(1/F)}{(\ln(2))^2}\right).
$$
Хоча це може не здаватися значним стисненням, слід зазначити, що фільтри Блума використовують елементарні біти для відстеження членства довільних елементів, таких як рядки. Крім того, завдяки бітовим операціям, які можна реалізувати дуже ефективно з низькорівневими реалізаціями, загальний підхід зазвичай дуже ефективний.

Слід пам'ятати, що значення n наперед невідоме для багатьох застосувань. Тому одна стратегія полягає у використанні каскаду фільтрів Блума для геометрично зростаючих значень u та використанні логічного AND результату запиту на членство над різними фільтрами Блума. Це практичний підхід, який забезпечує більш стабільну продуктивність протягом усього життєвого циклу потоку даних.

Фільтр Блума називається "фільтром", оскільки його часто використовують для прийняття рішень про виключення елементів з потоку даних, коли вони відповідають умові членства.